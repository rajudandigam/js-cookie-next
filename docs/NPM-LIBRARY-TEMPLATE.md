# NPM Library Development Template

**Source:** Derived from the full analysis of `react-copy-to-clipboard-lite`.  
**Purpose:** Reusable blueprint for building another npm library with the same quality bar: architecture-first design, Cursor/AI guardrails, unit + E2E testing, packaging, and release automation.

---

## 1. Overview: How This Library Was Built

### 1.1 Build chronology (from git history)

1. **Foundation** — `.cursorrules`, `.cursor/rules/architecture.mdc`, `docs/DEV-ARCHITECTURE.md`, `.gitignore` (architecture and guardrails first).
2. **Package and tooling** — `package.json`, `tsconfig.json`, Vitest config.
3. **Core** — Types → fallback/helpers → main engine (no React).
4. **React layer** — Hook → Component → Actions.
5. **Packaging** — `tsup.config.ts`, entry points (`index`, `core`, `react`), `exports` in `package.json`.
6. **Unit tests** — Vitest + jsdom + `@testing-library/react`; tests next to source (`src/**/__tests__/`).
7. **Demo app** — Vite + React demo in `demo/`, used for manual verification and E2E.
8. **E2E** — Playwright (Chromium, Firefox, WebKit), smoke tests against demo.
9. **CI** — GitHub Actions: setup/build artifact, typecheck, unit (with coverage), size-limit, Playwright.
10. **Release** — Changesets + GitHub Action for version-and-publish on `main` (OIDC/npm provenance).

### 1.2 Design principles

- **Single source of truth:** All API contract, engine behavior, build order, and testing strategy live in `docs/DEV-ARCHITECTURE.md`. Cursor rules point to it.
- **Strict guardrails:** `.cursorrules` and always-applied rule enforce TypeScript strict, no banned patterns (e.g. no `prompt()`), and consistent return types.
- **Layered packages:** Core (framework-agnostic) → React-specific entry; tree-shakeable and bundle-clean (e.g. core has no React).
- **Tests as spec:** Unit tests validate tiers, metadata, and edge cases; Playwright validates real browser behavior and demo scenarios.
- **Automation:** One-command “done” check (`test:all`), prepublish checks, and CI mirror local expectations.

---

## 2. Folder Structure (Reusable Pattern)

```
<library-root>/
├── src/
│   ├── core/                    # Framework-agnostic logic (no React)
│   │   ├── types.ts
│   │   ├── *.ts                  # Helpers, fallbacks, main engine
│   │   └── __tests__/
│   ├── react/                    # Or "vue", "solid", etc.
│   │   ├── *.ts / *.tsx
│   │   └── __tests__/
│   ├── index.ts                  # Main entry (re-exports)
│   ├── core.ts                   # Core-only entry
│   └── react.ts                  # Framework entry
├── tests/                        # Optional: extra integration tests
├── playwright/
│   ├── playwright.config.ts
│   └── tests/                    # E2E specs
├── demo/                         # Dev/demo app (Vite, etc.)
│   ├── index.html
│   ├── main.tsx
│   ├── vite.config.ts
│   └── styles.css
├── docs/
│   ├── DEV-ARCHITECTURE.md       # Single source of truth
│   └── NPM-LIBRARY-TEMPLATE.md   # This file
├── .github/workflows/
│   ├── ci.yml
│   └── publish.yml
├── .changeset/
│   ├── config.json
│   └── README.md
├── .cursor/
│   └── rules/
│       └── architecture.mdc      # Always-applied, points to docs
├── .cursorrules
├── package.json
├── tsconfig.json
├── tsup.config.ts                # Or similar bundler
├── vitest.config.ts
├── README.md
├── CHANGELOG.md                  # Often generated by changesets
└── LICENSE
```

**Reusable ideas:**

- **Core vs framework:** Keep core in `src/core/` with zero framework imports; framework bindings in `src/react/` (or equivalent). Enables separate entry points and bundle checks (e.g. “core must not contain React”).
- **Colocated tests:** `src/**/__tests__/*.test.ts(x)` keeps tests next to implementation; Vitest excludes from `tsconfig` build.
- **Demo as E2E target:** Demo app imports built `dist/` (via Vite alias in dev); Playwright runs against the same app. One app for both human demo and automated smoke tests.

---

## 3. Architecture Document (Single Source of Truth)

**Location:** `docs/DEV-ARCHITECTURE.md`

**Recommended sections (adapt names to your library):**

1. **Goal and scope** — One-line goal, must-have features (v1), explicit non-goals.
2. **Public API contract** — Types and function signatures that are the **contract**; implementations and PRs must match.
3. **Engine / core design** — Tiers, fallbacks, edge cases (e.g. SSR, permissions, errors). Tables and bullet lists.
4. **Repo and file layout** — Exact paths (e.g. `src/core/types.ts`) so Cursor and humans know where things live.
5. **Build order (implementation sequence)** — Ordered list: e.g. types → helpers → engine → hook → component → actions → exports → tests → docs.
6. **Testing plan** — What Vitest must cover (tiers, metadata, cleanup); what Playwright must cover (browsers, scenarios).
7. **Packaging and release** — Bundler, entry points, `exports`, `sideEffects`, React/RSC notes, license, changesets, CI.
8. **Cursor workflow** — Guardrails summary, build order reference, **prompt templates** (copy-paste for Cursor).
9. **Execution checklist (definition of done)** — Checkboxes for “ready to ship”.
10. **Roadmap (v1.1+)** — Optional future work.

**Why it matters:** Every Cursor rule and prompt points to this file. New contributors (human or AI) get one place to read before implementing or reviewing.

---

## 4. Cursor Rules and Guardrails

### 4.1 Root guardrails: `.cursorrules`

Short, always-on rules. No implementation detail; only constraints and pointers.

**Template (customize per library):**

```text
# <library-name> — Cursor guardrails

- **TypeScript**: Use strict TypeScript. No extra runtime dependencies. [Add library-specific bans, e.g. no prompt(), no clipboard-read.]
- **Return type**: All [relevant] paths must return [structured type, e.g. CopyResult].
- **SSR-safe**: No access to `window` or `document` at module top-level; guard with `typeof window === 'undefined'` and run browser logic only inside functions invoked at runtime.
- **Full context**: For API contract, [engine/design], build order, and tests, see `docs/DEV-ARCHITECTURE.md`.
- Only necessary and meaningful comments.
- No console logs.
```

**Reusable:** One file, bullet list, “see docs/DEV-ARCHITECTURE.md” for full context.

### 4.2 Always-applied rule: `.cursor/rules/architecture.mdc`

**Template:**

```yaml
---
description: <library-name> architecture and lifecycle context
alwaysApply: true
---

# <library-name>

One-line description. Full API contract, [engine/design], build order, testing, and packaging are in **docs/DEV-ARCHITECTURE.md** — read that file when implementing, scaffolding, or reviewing.
```

**Reusable:** `alwaysApply: true` plus one paragraph that points to the single source of truth. No duplication of contract or build order.

### 4.3 How prompts use the architecture

- **Implement X:** “Implement [X] as specified in docs/DEV-ARCHITECTURE.md, section N and API contract.”
- **Review:** “Check implementation against docs/DEV-ARCHITECTURE.md (contract, build order, testing plan).”
- **Scaffold:** “Follow the build order in docs/DEV-ARCHITECTURE.md; create only the next step.”

The architecture doc contains **prompt templates** (e.g. “Engine: Implement copyToClipboard(…) with tiered …”). Those are copy-paste snippets for Cursor so each feature request is consistent with the spec.

---

## 5. Implementation Order (Build Order)

**Reusable sequence (adjust names to your API):**

1. Core types (`src/core/types.ts`)
2. Helpers / fallbacks (`src/core/fallback.ts` or similar) — no React
3. Main engine (`src/core/copy.ts` or main entry) — uses types + fallbacks, returns structured result
4. Hook (`src/react/useCopyToClipboard.ts`) — uses core only
5. Component (`src/react/CopyToClipboard.tsx`) — uses core + cloneElement/injection pattern
6. Actions / form integration (`src/react/actions.ts` + `copyToClipboardAction.ts`)
7. Packaging exports (`src/index.ts`, `src/core.ts`, `src/react.ts`)
8. Unit tests (Vitest) for core, then hook, then component, then action
9. Demo app (Vite + React) that uses all entry points
10. Playwright smoke tests against demo
11. Docs and release (README, CHANGELOG, changesets)

**Why this order:** Types and engine are stable first; React layer stays thin and testable with mocks; E2E runs against real built artifacts and demo.

---

## 6. Unit Testing (Vitest)

### 6.1 Setup

- **Runner:** Vitest.
- **Environment:** `jsdom` for React components and DOM-dependent core.
- **Config:** `vitest.config.ts` — exclude `node_modules`, `dist`, `playwright/**`, demo; coverage with v8, thresholds (e.g. statements 95%, branches 90%), exclude entry barrels and config files from coverage.

### 6.2 Patterns used

- **Core engine:** Mock `global.navigator.clipboard`, `navigator.permissions`, `document.execCommand`, `document.queryCommandSupported`, `window.isSecureContext`; delete `window`/`document` for SSR test. Assert on structured result (`success`, `method`, `code`).
- **Fallback only:** Mock `document`/`window` where needed; test cleanup and error paths.
- **Hook:** `vi.mock("../core/copy.js")`, `renderHook` + `act`; test initial state, success, timeout reset, `reset()`, failure, unmount (no state update after unmount, timer cleared).
- **Component:** Mock core; `render` + `fireEvent.click`; assert call args, child `onClick` order, `preventDefault` behavior, `onSuccess`/`onError`/`onCopyResult`.
- **Action:** Mock core; FormData with `text`; assert delegation to core and return value; test missing/coerced text, previous state ignored.

### 6.3 Reusable bits

- Colocated `__tests__` next to source.
- One mock of core for all React tests (no real clipboard in unit tests).
- Fake timers for timeout and clearAfter.
- Coverage thresholds and exclusion list in one place.

---

## 7. E2E Testing (Playwright)

### 7.1 Setup

- **Config:** `playwright/playwright.config.ts` — `testDir: "tests"` (i.e. `playwright/tests/`), webServer: `npm run dev:demo`, baseURL, Chromium/Firefox/WebKit, retries 2, trace on failure.
- **Run:** `npm run test:pw` with config path so CI and local use same config.
- **Demo:** Must be built (or dev server) so demo imports from `dist/` (alias in demo’s Vite config).

### 7.2 Patterns used

- **Clipboard:** In Chromium, `context.grantPermissions(["clipboard-read", "clipboard-write"])` then `page.evaluate(() => navigator.clipboard.readText())` to assert content. Skip clipboard-read assertions in WebKit where unsupported.
- **Stability:** `data-testid` on buttons and result areas; `expect(…).toHaveText("true")` for copied state.
- **Fallback path:** `page.addInitScript` to set `isSecureContext: false` or stub `navigator.clipboard.writeText` to reject; then assert copy still succeeds (execCommand path).
- **Error UI:** Stub clipboard + execCommand to fail; assert error state visible.
- **Multiple scenarios:** Hook copy, clearAfter, component click, child onClick, preventDefault, form action, multiline, input field, reset, metadata (method).

### 7.3 Reusable bits

- Single demo app as target; one Playwright config; three browsers.
- `data-testid` convention for stable selectors.
- Optional upload of Playwright report artifact on failure in CI.

---

## 8. Demo Application

### 8.1 Role

- Show all public APIs (core, hook, component, action).
- Use built package via Vite alias (e.g. `react-copy-to-clipboard-lite` → `../dist/index.mjs`, `react-copy-to-clipboard-lite/react` → `../dist/react.mjs`) so demo always tests the real build.
- Provide `data-testid` and stable text/roles for Playwright.

### 8.2 Setup (Vite + React)

- **Config:** `demo/vite.config.ts` — root `__dirname`, resolve alias to `../dist/*.mjs`, server port, build outDir.
- **Scripts:** `dev:demo` runs Vite with that config; `build:demo` builds library then builds demo.
- **Entry:** `demo/index.html` + `demo/main.tsx`; import from package name (resolved to dist).

### 8.3 Reusable bits

- Demo in a `demo/` folder; separate Vite config; alias to dist so “dev” tests the built output.
- Sections per API surface (Hook, Component, Action, Core) with clear labels and test ids.

---

## 9. Packaging (tsup)

### 9.1 Entry points

- **Main:** `src/index.ts` → re-exports core + react.
- **Core only:** `src/core.ts` → re-exports core (no React).
- **React only:** `src/react.ts` → re-exports hook, component, actions.

### 9.2 tsup config

- Entry: `index`, `core`, `react`.
- Format: `["esm", "cjs"]`.
- Output: `dist/*.mjs`, `dist/*.cjs`, `dist/*.d.ts`.
- `external: ["react"]` so React is not bundled.
- `minify: true`, `treeshake: true`, `target: "es2020"`.
- Optional: `outExtension` so CJS is `.cjs`, ESM is `.mjs`. Clean `.d.cts` if generated (e.g. post-build `rm -f dist/*.d.cts`).

### 9.3 package.json

- **type:** `"module"`.
- **main:** `./dist/index.cjs`, **module:** `./dist/index.mjs`, **types:** `./dist/index.d.ts`.
- **exports:** Conditional exports per entry:
  - `"."` → types, import (mjs), require (cjs)
  - `"./core"` → core-only
  - `"./react"` → react-only
- **files:** `["dist"]`.
- **sideEffects:** `false`.
- **peerDependencies:** e.g. `react: ">=18"`.

### 9.4 Bundle hygiene

- **check:bundle:** e.g. `grep -q "react" dist/core.mjs && exit 1` so core stays React-free. Run in CI and prepublish.

---

## 10. Size and Quality Gates

### 10.1 size-limit

- **Preset:** `@size-limit/preset-small-lib` (or none).
- **Entries:** e.g. `dist/index.mjs`, `dist/react.mjs` with limits in KB. CI runs `npm run size` after build.

### 10.2 Scripts (reusable pattern)

```json
"test:all": "npm run typecheck && npm run build && npm run test && npm run test:pw && npm run size && npm run check:bundle",
"prepublish:checks": "npm run typecheck && npm run test && npm run build && npm run size && npm run check:bundle",
"prepack": "npm run clean && npm run build",
"prepublishOnly": "npm run prepublish:checks",
"prepare": "npm run build"
```

- **test:all** — Full pipeline (typecheck, build, unit, E2E, size, bundle check). “Definition of done” for a PR.
- **prepublish:checks** — Same without E2E if desired, or keep E2E for maximum safety.
- **prepack** — Clean + build so `npm pack` and publish use fresh dist.
- **prepublishOnly** — Guard so `npm publish` always runs checks first.

---

## 11. GitHub Actions

### 11.1 CI (`ci.yml`)

- **Triggers:** push/PR to `main`.
- **Concurrency:** cancel in progress.
- **Jobs:**
  - **setup:** Checkout, Node 20, `npm ci`, `npm run build`, upload `dist` artifact.
  - **typecheck:** `npm run typecheck`.
  - **unit:** `npm run test -- --coverage`; upload coverage artifact.
  - **build-check:** Build again, assert dist files exist.
  - **size:** `npm run size`.
  - **playwright:** Install deps, build, `npx playwright install --with-deps`, `npm run test:pw`; on failure upload playwright-report.

**Reusable:** One setup job that produces dist; other jobs depend on it and can restore artifact if needed (this repo runs build again in each job for simplicity). Playwright runs after build so demo can resolve dist.

### 11.2 Release (`publish.yml`)

- **Trigger:** push to `main`.
- **Permissions:** `contents: write`, `pull-requests: write`, `id-token: write` (for OIDC).
- **Steps:** Checkout, Node 22, `npm ci`, `npm run build`, optionally upgrade npm for Trusted Publishing, remove auth token from `.npmrc`, then **changesets/action** with `publish: npm publish --access public --provenance`.
- **Changesets:** Create Release PR or publish on merge; commit message e.g. `chore: release`.

**Reusable:** Changesets drive versions and CHANGELOG; one workflow for “version + publish”. OIDC + provenance for npm.

---

## 12. Changesets

- **Config:** `.changeset/config.json` — baseBranch `main`, changelog generator (e.g. `@changesets/changelog-github` with repo), `commit: false` (action commits).
- **Usage:** Add a changeset (e.g. `npx changeset`), commit; merge to main; action opens “Version Packages” PR; merge that PR to publish and update CHANGELOG.

**Reusable:** Same flow for any single-package npm lib: changesets + one publish workflow.

---

## 13. Tools and Libraries Summary

| Concern        | Tool / library                          | Version (example)     |
|----------------|-----------------------------------------|------------------------|
| Build          | tsup                                    | ^8.0.0                 |
| TypeScript     | tsc (noEmit), strict                    | ^5.4.0                 |
| Unit test      | Vitest, jsdom                           | ^1.3.0                 |
| React testing  | @testing-library/react                  | ^16.0.0                |
| E2E            | @playwright/test                        | ^1.58.2                |
| Demo           | Vite, @vitejs/plugin-react              | ^7.x, ^5.x             |
| Size           | size-limit, @size-limit/preset-small-lib| ^12.0.0                |
| Version/publish| @changesets/cli, @changesets/changelog-github | ^2.x, ^0.5.x  |
| CI             | GitHub Actions                          | -                      |

**Reusable:** Same stack can be used for another React/TS library; swap “React” for another framework if needed.

---

## 14. Reusable Checklist for a New Library

1. **Docs first:** Create `docs/DEV-ARCHITECTURE.md` with goal, API contract, engine/design, file layout, build order, testing plan, packaging, Cursor prompt templates, and execution checklist.
2. **Cursor:** Add `.cursorrules` and `.cursor/rules/architecture.mdc` (alwaysApply, point to DEV-ARCHITECTURE.md).
3. **Package:** `package.json` with scripts (build, typecheck, test, test:pw, test:all, size, check:bundle, prepublish:checks, prepack, prepublishOnly, prepare), exports, peerDependencies, size-limit.
4. **TypeScript:** `tsconfig.json` (strict, exclude tests from build).
5. **Build:** tsup (or similar) with entry points and externals.
6. **Core:** Implement in order: types → helpers → engine; unit tests next to source.
7. **Framework layer:** Hook → component → actions; unit tests with mocks.
8. **Demo:** Vite app in `demo/` with alias to dist; use all public APIs and add data-testid.
9. **Playwright:** Config + smoke tests against demo; run in CI.
10. **CI:** `ci.yml` (setup, typecheck, unit, size, playwright); `publish.yml` (changesets + publish).
11. **Release:** Changesets config; first release PR and merge.
12. **README:** Install, usage, API summary, comparison/migration, contributing (e.g. “run test:all before PR”).

---

## 15. What to Copy vs Customize

**Copy almost as-is:**

- Folder layout (src/core, src/react, demo, playwright, .github, .changeset, .cursor).
- CI job structure and release workflow pattern.
- Vitest/Playwright config patterns and test layout.
- Script naming (test, test:watch, test:pw, test:all, prepublish:checks, prepack, prepublishOnly, check:bundle).
- Architecture doc structure and Cursor rule pattern (short guardrails + “see docs/DEV-ARCHITECTURE.md”).

**Customize per library:**

- Content of `docs/DEV-ARCHITECTURE.md` (API contract, engine tiers, prompt templates).
- `.cursorrules` bullets (banned patterns, return types, SSR rules).
- Entry points (e.g. no `core` if everything is React).
- size-limit limits and check:bundle logic.
- Demo app UI and scenarios; Playwright test cases.
- Dependencies (e.g. no React for a vanilla lib).

---

This template captures the **current architecture, implementation order, use of prompts and Cursor rules, testing strategy, packaging, npm publish, GitHub CI/release, folder structure, demo app role, and reusable patterns** from react-copy-to-clipboard-lite so you can reuse them when building another npm library.
